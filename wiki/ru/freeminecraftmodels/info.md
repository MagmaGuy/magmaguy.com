[![webapp_banner.jpg](../../../img/wiki/webapp_banner.jpg)](https://magmaguy.com/webapp/webapp.html)

# FreeMinecraftModels (FMM)

# ***Прежде чем начать!***

FreeMinecraftModels (FMM)  в данный момент находится в  **альфа-версии**!  Это означает, что некоторые функции еще не реализованы и активно разрабатываются.

Однако на данный момент  ядро  плагина  полностью  функционально -  конвертация  файлов  bbmodel,  генерация  пакетов  ресурсов,  появление  сущностей  в  игре  и  управление  их  анимацией  -  все  работает,  хотя,  возможно,  не  на  100%  отполировано.

Подумайте  о  поддержке  разработки  на  https://www.patreon.com/magmaguy !

Экспортируемое  содержимое  пакета  ресурсов  лицензируется  по  лицензии  CC0,  без  всяких  прав.  Вы  свободны  использовать,  распространять,  модифицировать  для  любых  целей  без  ограничений  и  не  требуется  указание  авторства.

# Использование  этого  плагина

## Что  FreeMinecraftModels (FMM)  может  сделать  для  администраторов  Minecraft  серверов?

Он  может:

- Импортировать  .bbmodel  или  fmmodel  (кастомный  формат  FFM)  модели
- Генерировать  пакеты  ресурсов  с  моделями,  которые  превышают  обычные  ограничения  модели  пакета  ресурсов  Minecraft  (до  ~~112x112x112~~  106x106x106  единиц  или  7x7x7  блоков  в  игре)
- Отображать  эти  модели  в  игре  с  помощью  команды  `/fmm spawn static <id>`,  где  id  -  это  имя  файла  модели,  в  нижнем  регистре  и  без  расширения  файла
- Анимировать  эти  модели  так,  как  они  были  настроены  на  анимацию  в  Blockbench
- Обрабатывать  стандартные  анимации  состояний  без  необходимости  в  других  плагинах  (ходьба,  ожидание,  смерть,  атака,  появление)

### Как  добавить  существующую  модель?

Чтобы  импортировать  модель,  просто  перетащите  .bbmodel  в  папку  импорта  и  выполните  `/fmm reload`.  Это  сгенерирует  файл  .fmmodel  в  папке  `models`  и  добавит  модель  в  пакет  ресурсов  в  папке  `outputs`.

***Вам  необходимо  использовать  этот  пакет  ресурсов,  чтобы  правильно  просмотреть  модель!***  Это  обычный  пакет  ресурсов,  поэтому  все,  что  вам  нужно  сделать,  -  это  поместить  его  в  папку  с  пакетом  ресурсов.  Серверы  Minecraft  имеют  возможность  хостить  пакеты  ресурсов  на  сторонних  сервисах,  таких  как  google  drive  или  специализированный  сервис,  например,  https://resourcepack.host/,  этот  последний  сайт,  возможно,  является  самым  простым  способом  сделать  это.

### Как  просмотреть  модель  в  игре?

Существует  две  (планируемые)  категории  моделей.

- `Static`  модели  предназначены  для  моделей,  которые  не  движутся  (но  могут  иметь  анимации)  и  являются  более  декоративными  -  представьте  себе  что-то  вроде  фонарного  столба  или  елки.
- `Dynamic`  модели  предназначены  для  моделей,  которые  ведут  себя  как  мобы  Minecraft,  то  есть  они  движутся  и  выполняют  различные  действия,  связанные  с  мобами.  Представьте  себе  что-то  вроде  кастомных  моделей  боссов  или  добавления  совершенно  новых  типов  сущностей  в  Minecraft.

####  Просмотр  статических  моделей  в  игре

Чтобы  просмотреть  статические  модели  в  игре,  используйте  команду  `/fmm spawn static <id>`,  где  id  -  это  имя  файла  модели,  в  нижнем  регистре  и  без  расширения  файла.

####  Просмотр  динамических  моделей  в  игре

Чтобы  просмотреть  динамические  модели  в  игре,  используйте  команду  `/fmm spawn dynamic <id>`,  где  id  -  это  имя  файла  модели,  в  нижнем  регистре  и  без  расширения  файла.

## Что  FreeMinecraftModels (FMM)  может  сделать  для  модельеров?

FMM  следует  стандартным  правилам  пакета  ресурсов  для  генерации  пакетов  ресурсов.  Кроме  того,  он  пытается  быть  как  можно  более  совместимым  с  моделями,  совместимыми  с  ModelEngine,  чтобы  попытаться  стандартизировать  создание  моделей  в  разных  плагинах.

###  Функции/ограничения  генерации  моделей

Если  вы  когда-либо  создавали  модели  для  ModelEngine,  вы  будете  знакомы  со  многими  ограничениями  генерации  пакета  ресурсов  Minecraft:

#### **Кубы:**

Кубы  здесь  те  же,  что  и  в  Blockbench,  это  кубы,  из  которых  состоит  модель.

- Кубы  могут  быть  размером  до  ~~112x112x112~~  106x106x106  "пикселей"  (единицы  Blockbench)  или  7x7x7  блоков  в  игре  (стандартные  ограничения  Minecraft  обходят  с  помощью  размеров  отображения,  скоро  будут  дальнейшие  обходы  для  1.19.4+  благодаря  сущностям  отображения)
- Допустимые  вращения  для  кубов  -  0,  22.5,  -22.5,  45  и  -45.  Другое  вращение  не  работает.
- Кубы  вращаются  только  по  одной  оси,  то  есть  вращение  [22.5,  0,  0]  -  нормально,  вращение  [22.5,  0,  45]  будет  работать  не  полностью  и  будет  вращаться  только  по  одной  оси.

#### **Кости:**

Кости  -  это  то,  что  Blockbench  называет  "группами".  Они  служат  для  группировки  кубов  вместе  и  должны  использоваться  для  группировки  костей  вместе  для  анимацииBlueprint.

- Кости  могут  быть  размером  до  ~~112x112x112~~  106x106x106  (должно  быть  112,  не  уверен,  почему  так)  "пикселей"  (единицы  Blockbench)  или  7x7x7  блоков  в  игре.  *Обратите  внимание,  что  размер  костей  устанавливается  тем,  что  в  них  находится,  поэтому,  если  у  вас  есть  кубы,  которые  находятся  на  расстоянии  более  7  блоков  друг  от  друга,  вы,  вероятнее  всего,  превысите  этот  предел  размера.  Обход  этого  предела  прост:  поместите  блоки  в  другую  boneBlueprint,  не  входящую  в  первую  boneBlueprint!*
- Можно  вращать  любым  образом!

Кости  значительно  более  гибкие,  чем  кубы,  но  вы  должны  использовать  как  можно  меньше  костей!  В  FMM  из-за  ограничений  Minecraft  каждый  boneBlueprint  -  это  отдельная  сущность.  В  масштабе  это  довольно  быстро  повлияет  на  производительность!  Всегда  используйте  как  можно  меньше  костей  и  помните  о  том,  сколько  этих  моделей  вы  планируете  генерировать -  чем  больше  их  у  вас  будет,  тем  меньше  костей  вам  нужно!

#### **Виртуальные кости**

Если  вы  пришли  из  ModelEngine,  вам,  вероятно,  интересно,  есть  ли  в  FMM  виртуальные  кости  и  как  они  реализованы.  Виртуальные  кости  были  запланированы,  но  в  настоящее  время  реализованы  только  на  очень  основах.

Однако  по  крайней  мере  следующие  виртуальные  boneBlueprint  скоро  будут  совместимы  с  FMM:

-  Hitboxes /  eye  height:  boneBlueprint  с  именем  "hitbox"  с  cubeBlueprint,  который  определяет  границы  и  имеет  одинаковое  значение  x  и  z  (будет  выбрано  самое  большое  значение,  если  они  не  одинаковые),  определяет  hitbox.  Уровень  глаз  устанавливается  в  точке  вращения  boneBlueprint  hitbox.
-  Tag  name:  boneBlueprint,  имя  которого  начинается  с  "tag_".  Честно  говоря,  я  предпочел  бы  быть  более  конкретным  здесь  и  использовать  "tag_name",  чтобы  использовать  теги  для  других  вещей,  но  это  будет  серьезно  рассмотрено  позже.

Не  гарантируется,  что  в  ближайшем  будущем  будут  добавлены  другие  функции  виртуального  boneBlueprint.

## Слияние  пакетов  ресурсов

При  использовании  FMM  вам,  вероятно,  потребуется  объединять  пакеты  ресурсов.

Вы  можете  объединять  пакеты  ресурсов  вручную,  но  мы  рекомендуем  использовать  онлайн-инструмент,  например,  [merge.elmakers](https://merge.elmakers.com/),  для  объединения  ваших  пакетов  ресурсов.

#### **Более  безопасная,  простая  и  нередактируемая  дистрибуция  файлов**

Одна  из  вещей,  с  которой  пытается  справиться  FMM,  -  это  переработка  моделей  пользователями,  которые  их  получили,  чтобы  редактировать  их  так,  как  создатель  модели  не  хотел,  чтобы  они  их  редактировали,  в  частности,  чтобы  изменить  skin  или  немного  изменить  модель  и,  возможно,  попробовать  перепродать  ее  как  оригинальную  работу.

С  этой  целью  FMM  использует  формат  файла  `.fmmodel`,  который  стремится  удалить  файлы  `.bbmodel`  до  того  как  они  могут  быть  использованы  плагином,  но  не  могут  быть  отредактированы  в  Blockbench.

Как  модельер,  теперь  у  вас  есть  выбор,  хотите  ли  вы  выпустить  нередактируемый  файл  `.fmmodel`,  редактируемый  файл  `.bbmodel`  или  даже  установить  разные  цены  или  условия  обслуживания  для  двух  вариантов.

Генерация  `.fmmodel`  проста  как  поместить  ваш  `.bbmodel`  в  папку  `~/plugins/FreeMinecraftModels/imports`  и  перезагрузить  плагин  с  помощью  `/fmm reload`  или  перезапустить  сервер.  Ваш  `.fmmodel`  будет  затем  в  папке  `~/plugins/FreeMinecraftModels/models`.

## Что  FreeMinecraftModels (FMM)  может  сделать  для  разработчиков,  которые  хотят  интегрировать  его  в  свои  плагины?

У  FMM  есть  репозиторий  maven!
Maven:

```xml

<repository>
    <id>ossrh-public</id>
    <url>https://s01.oss.sonatype.org/content/groups/snapshots/</url>
</repository>

<dependency>
<groupId>com.magmaguy</groupId>
<artifactId>FreeMinecraftModels</artifactId>
<version>1.1.3-SNAPSHOT</version>
<scope>provided</scope>
</dependency>
```

Gradle:

```kotlin
compileOnly group : 'com.magmaguy', name: 'FreeMinecraftModels', version: '1.1.2-SNAPSHOT'
```

*Примечание:  FreeMinecraftModels  предназначен  для  использования  в  качестве  API  и  требует  установки  плагина  на  сервере.  Не  затеняйте  его  в  свой  plugin!*

FMM  стремится  быть  как  можно  более  простым  в  использовании  в  качестве  API.

Прямо  сейчас  есть  только  один  класс,  о  котором  вам  нужно  знать,  если  вы  хотите  использовать  FMM  в  качестве  API  для  вашего  plugin'а,  и  это  `StaticEntity`.

Вот  фрагмент  кода  для  обработки  статической  модели:

```java
public class FreeMinecraftModelsModel {
    private StaticEntity staticEntity = null;

    //Создание модели
    public FreeMinecraftModelsModel(String id, Location location) {
        //Это  генерирует  сущность!
        staticEntity = StaticEntity.create(id, location);
        //Это  проверяет,  правильно  ли  была  сгенерирована  сущность
        if (staticEntity == null) Logger.warningMessage("FMM  не  смогла  найти  модель  с  именем  " + id + " !");
    }

    public void remove() {
        //Это  удаляет  сущность
        staticEntity.remove();
    }
}
```

Помните, что  статические  модели  предназначены  для  того,  чтобы  оставаться  на  месте  и  выступать  в  качестве  декоративного  элемента  в  фиксированном  местоположении  (анимации  не  считаются  "движением"  здесь).  Хотя  их  можно  перемещать,  подумайте,  не  лучше  ли  вместо  этого  использовать  динамическую  модель,  если  это  ваша  цель.

А  вот  как  EliteMobs,  мой  plugin  Custom Bosses,  использует  динамические  сущности:

```java
package com.magmaguy.elitemobs.thirdparty.custommodels.freeminecraftmodels;

import com.magmaguy.elitemobs.mobconstructor.custombosses.CustomBossEntity;
import com.magmaguy.elitemobs.thirdparty.custommodels.CustomModelInterface;
import com.magmaguy.freeminecraftmodels.api.ModeledEntityManager;
import com.magmaguy.freeminecraftmodels.customentity.DynamicEntity;
import lombok.Getter;
import org.bukkit.entity.LivingEntity;

public class CustomModelFMM implements CustomModelInterface {
    @Getter
    private DynamicEntity dynamicEntity;

    public CustomModelFMM(LivingEntity livingEntity, String modelName, String nametagName) {
        dynamicEntity = DynamicEntity.create(modelName, livingEntity);
        if (dynamicEntity == null) return;
        dynamicEntity.setName(nametagName);
    }

    public static void reloadModels() {
        ModeledEntityManager.reload();
    }

    public static boolean modelExists(String modelName) {
        return ModeledEntityManager.modelExists(modelName);
    }

    @Override
    public void shoot() {
        if (dynamicEntity.hasAnimation("attack_ranged")) dynamicEntity.playAnimation("attack_ranged", false);
        else dynamicEntity.playAnimation("attack", false);
    }

    @Override
    public void melee() {
        if (dynamicEntity.hasAnimation("attack_melee")) dynamicEntity.playAnimation("attack_melee", false);
        else dynamicEntity.playAnimation("attack", false);
    }

    @Override
    public void playAnimationByName(String animationName) {
        dynamicEntity.playAnimation(animationName, false);
    }

    @Override
    public void setName(String nametagName, boolean visible) {
        dynamicEntity.setName(nametagName);
        dynamicEntity.setNameVisible(visible);
    }

    @Override
    public void setNameVisible(boolean visible) {
        dynamicEntity.setNameVisible(visible);
    }

    @Override
    public void switchPhase() {
        dynamicEntity.stopCurrentAnimations();
    }
}
```

Динамические модели строятся поверх живой сущности, которая может быть предоставлена либо при использовании метода create, как в примере выше, либо при выполнении метода spawn для Dynamic Entity.

Хотя формального ресурса API в данный момент нет, все элементы, предназначенные для использования API, содержатся в ModeledEntity (базовый класс для всех сущностей), StaticEntity, DynamicEntity и ModeledEntityManager. 99% разработчиков должны найти все необходимые им методы, распределенные по этим трем классам.

# Внесение вклада в проект FreeMinecraftModels (FMM) в качестве разработчика

FMM распространяется под лицензией GPLV3, и код  contributions  приветствуется.  Вот  основные  правила  contributions:

- Следуйте  существующим  конвенциям  имен,  сохраняйте  существующий  уровень  verbosity  и  добавляйте  достаточно  документации,  чтобы  ваша  contribution  была  легко  понятна.
-  Делайте  contributions  релевантными  для  области  действия  плагина.  Если  вы  не  уверены,  будет  ли  она  релевантной,  свободно  спросите  заранее.
-  Будьте  внимательны  к  влиянию  вашего  кода  на  производительность.  Некоторые  contributions  могут  быть  отклонены,  если  они  слишком  плохо  оптимизированы  или  иначе  вызывают  слишком  большое  влияние  на  производительность.

## Общая  схема  плагина

Чтобы  сэкономить  вам  немного  времени,  вот  краткое  разложение  логического  потока  FMM:

1) Чтение  папки  `imports`
2) Перемещение  файлов  из  папки  `imports`  в  папку  `models`.  Если  файл  -  `.bbmodel`,  он  конвертируется  в  `.fmmodel`  в  папке  `models`.
3) Чтение  файлов  в  папке  `models`.
4)  Интерпретация  всех  структур  моделей,  создание  `Skeleton`'ов,  которые  содержат  группы  `Bone`'ов,  а  эти  кости  содержат  группы  дочерних  `Bone`'ов  и  `Cube`'ов.  `Cube`'ы  и  `Bone`'ы  генерируют  данные  JSON  пакета  ресурсов,  к  которым  они  каждый  привязан.  Это  означает,  что  `Cube`'ы  генерируют  JSON,  специфичный  для  кубов,  а  `Bone`'ы  генерируют  контур  и  отдельные  файлы  boneBlueprint.  Обратите  внимание,  что  один  boneBlueprint  приводит  к  одному  файлу  пакета  ресурсов.  Модели  добавляются  в  список  по  мере  их  генерации.
5)  Еще  в  `Skeleton`  интерпретируются  все  `Animations`  в  модели,  если  они  есть.
6)  Все  данные  теперь  инициализированы,  пакет  ресурсов  был  сгенерирован  в  папке  `outputs`,  и  плагин  готов  к  использованию.

##  Хитрости,  используемые  в  этом  плагине:

Хитрости,  используемые  здесь,  довольно  известны  и  стандартизированы,  но  будут  перечислены  тем  не  менее,  потому  что  могут  быть  не  интуитивно  понятными.

Обратите  внимание,  что  эти  хитрости  полностью  невидимы  для  пользователей  и  модельеров;  ограничения  и  обходные  пути  указаны  только  для  того,  чтобы  помочь  вам  понять,  как  FMM  обходит  различные  ограничения  Minecraft.

-  Все  модели  масштабируются  в  4  раза,  а  затем  размер  и  точка  вращения  перенастраиваются  в  коде,  чтобы  расширить  теоретический  максимальный  размер  модели.
-  Поскольку  модели  пакета  ресурсов  могут  иметь  размер  только  от  -16  до  +32,  модели  сдвигаются  на  задний  план.  Это  полностью  невидимо  для  игроков.
-  Кожаная  броня  для  лошадей  используется  для  создания  моделей  с  оттенком,  который  можно  изменить  с  помощью  кода  (например,  для  обозначения  урона).  Броня  для  лошадей  должна  быть  белой,  чтобы  отображались  правильные  цвета!
-  Blockbench  использует  специальную  систему  ID  для  текстур,  но  на  самом  деле  читает  текстуры  последовательно  из  конфигурации.  Здесь  ID  присваиваются  в  соответствии  с  их  положением  в  списке  текстур,  следуя  тому,  как  это  делает  Blockbench.
-  Каждый  boneBlueprint  -  это  отдельная  сущность  стенда  брони  из-за  ограничений  Minecraft.
-  Кожаная  броня  для  лошадей  находится  в  слоте  головы  стенда  брони.
-  Стенды  брони  используются  для  стандартных  статических  предметов.  //todo:  скоро  мне  придется  реализовать  новую  альтернативную  систему  отображения  из  MC  1.19.4+,  она  гораздо  эффективнее.
-  Чтобы  избежать  конфликтов  с  другими  плагинами,  которые  модифицируют  кожаную  броню  для  лошадей,  FMM  использует  значения  данных  Custom Model,  начиная  с  50 000.

#  Внесение  вклада  в  проект  FreeMinecraftModels (FMM)  в  общем

FMM  фактически  финансируется  замечательными  людьми  с  [https://www.patreon.com/magmaguy](https://www.patreon.com/magmaguy)!  Все  contributions  помогают  больше,  чем  вы  думаете ;)

#  Планируемые  функции:
- Генерация  RSP  для  клиентов  Bedrock.
-  Управление  RSP  независимо  от  свойств  сервера  с  интеграцией  Geyser.
-  Custom  entities  (?).
-  tag_projectile  как  meta  bones,  из  которых  можно  стрелять  снарядами  (может  быть  более  одного  на  модель).

#  Текущие  странные  ограничения,  которые  нужно  исправить:
-  Если  точка  вращения  (источник)  boneBlueprint  установлена  выше  67,  модель  начинает  плавать.

